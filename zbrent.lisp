(in-package :cl-fiber-prop)

(define-condition root-not-bracketed () ())
(define-condition max-iterations-exceeded () ())

(defun zbrent (fun x1 x2 &optional (tol 1d-6) (itermax 100))
  "Find zero of function fun between x1 and x2. Reference: Numerical Recipes in C"
  (declare (type (function (double-float) (values double-float &optional)) fun)
	   (type double-float x1 x2 tol)
	   (type (integer 0 100000) itermax)
	   (values double-float &optional))
  (let* ((a x1) (b x2) (c x2) (d 0d0) (e 0d0)
	 (fa (funcall fun a)) (fb (funcall fun b)) (fc fb))
    (declare (type double-float a b c d e fa fb fc))
    (when (or (and (< 0 fa) (< 0 fb))
	      (and (< fa 0) (< fb 0)))
      (error 'root-not-bracketed))
    (loop for iter below itermax do
	 (when (or (and (< 0 fc) (< 0 fb))
		   (and (< fc 0) (< fb 0)))
	   (setf c a  fc fa  e (- b a)  d e))
	 (when (< (abs fc) (abs fb))
	   (setf a b b c c a)
	   (setf fa fb fb fc fc fa))
	 (let ((tol1 (+ (* .5 tol)
			(* 2 double-float-epsilon (abs b))))
	       (xm (* .5 (- c b))))      (declare (type double-float tol1 xm))
	       (when (or (and (<= (abs xm) tol1)
			      (<= (abs fb) 1e-3))
			 (= fb 0))
		 (return-from zbrent b))
	   (if (and (<= tol1 (abs e))
		    (< (abs fb) (abs fa)))
	       (let ((p 0d0) (q 0d0) (r 0d0) (s (/ fb fa))) (declare (type double-float p q r s))
		 (if (= a c)
		     (setf p (* 2 xm s)  q (- 1 s))
		     (setf q (/ fa fc)  r (/ fb fc)  p (* s (- (* 2 xm q (- q r))
							       (* (- b a) (- r 1))))
			   q (* (- q 1) (- r 1) (- s 1))))
		 (when (< 0 p) (setf q (- q)))
		 (setf p (abs p))
		 (if (< (* 2 p) (min (- (* 3 xm q) (abs (* tol1 q))) (abs (* e q))))
		     (setf e d  d (/ p q))
		     (setf d xm  e d)))
	       (setf d xm  e d))
	   (setf a b  fa fb)
	   (incf b (if (< tol1 (abs d)) d   (* (abs tol1) (signum xm))))
	   (setf fb (funcall fun b))))
    (error 'max-iterations-exceeded)))

#+nil
(zbrent #'sin 1d0 4d0)
