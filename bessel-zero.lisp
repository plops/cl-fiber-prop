#+nil (defun besspqa (a x eps pa qa pa1 qa1)
  (let* ((rev (< a -.5))
	 na)
    (when rev (setf a (+ (- a) -1)))
    (let ((rec (<= .5 a)))
      (if rec
	  (setf na (floor (+ a .5))
		a (- a na)))
      (if (= a -.5)
	  (setf pa 1
		pa1 1
		qa 0
		qa1 0)
	  (setf c (+ .25 (* -1 a a))
		b (+ x x)
		p pi
		e (expt (* x (/ (cos (* a p))
				(* p eps))) 2)
		p 1
		q (- x)
		r (+ 1 (* x x))
		s r)))))

(declaim (optimize (debug 3) (speed 0) (safety 3)))

#+nil
(bessr () 
	     (besspqa a x e pa qa pa1 qa1)
	     (setf chi (- x psi))
	     (let ((si (sin chi))
		   (co (cos chi)))
	       (ecase d
		 (1 (/ (- (* pa co) (* qa si))
		       (+ (* pa1 si) (* qa1 co))))
		 (2 (/ (+ (* pa si) (* qa co))
		       (- (* qa1 si) (* pa1 co))))
		 (3 (- (/ a x)
		       (/ (+ (* pa1 si) (* qa1 co))
			  (- (* pa co) (* qa si)))))
		 (4 (- (/ a x)
		       (/ (- (* qa1 si) (* pa1 co))
			  (+ (* pa si) (* qa co))))))))


(require :cffi)
(cffi:defcfun jn :double (n :int) (x :double))
(cffi:defcfun yn :double (n :int) (x :double))


(defun bess-zeros (&key (a 0) (n 10) (d 1) (e 1d-6))
  "Compute the first n zeros of a bessel function. d determines the type of the bessel function: 1.. J_a, 2.. Y_a, 3.. J_a', 4.. Y_a'; a is the order, e is the measure of relative accuracy."
  (declare (type (integer 0 1000) a n)
	   (type (integer 1 4) d)
	   (type (double-float 0d0) e))
  (let* ((z (make-array n :element-type 'double-float))
	 (chi 0d0) (psi 0d0) (p 0d0) (p0 0d0) (p1 0d0) (q1 0d0) (qq1 0d0) (pp1 0d0) (qa 0d0) (pa 0d0) (pa1 0d0) (qa1 0d0) (x 0d0))
    (declare (type double-float chi psi p p0 p1 q1 qq1 pp1 qa pa pa1 qa1 x))
    (flet ((fi (y)
	     (when (= y 0) (return-from fi 0d0))
	     (when (< 100000 y) (return-from fi 1.570796d0))
	     (let ((p 0d0)
		   (pp 0d0))
	       (if (< y 1)
		   (setf p (expt (* 3d0 y) 1/3)
			 pp (* p p)
			 p (* p (+ 1 (* 1/1575 pp (+ -210 (* pp (- 27 (* 2 pp))))))))
		   (setf p (/ (+ y 1.570796d0))
			 pp (* p p)
			 p (- 1.570796d0 (* 1/3465 p (+ 1 (* pp (+ 2310 (* pp (+ 3003 (* pp (+ 4818 (* pp (+ 8591 (* pp 16328))))))))))))))
	       (setf pp (expt (+ y p) 2))
	       (let ((r (/ (- p (atan (+ y p))) pp)))
		 (- p (* (+ 1 pp) r (+ 1 (/ r (+ y p))))))))
	   (bessr (d a x)
	     (ecase d
	       (1 (/ (jn a x) (jn (+ a 1) x)))
	       (2 (/ (yn a x) (yn (+ a 1) x)))
	       (3 (- (/ a x) (/ (jn (+ a 1) x) (jn a x))))
	       (4 (- (/ a x) (/ (yn a x) (yn (+ a 1) x)))))))
      (let* ((aa (* a a)) (mu (* 4d0 aa)) (mu2 (* mu mu)) (mu3 (* mu mu2)) (mu4 (* mu2 mu2)))
	(if (< d 3)
	   (setf p (- (* 7 mu) 31)
		 p0 (- mu 1)
		 p1 (if (= (+ 1 p) p) 0d0 (* 4/15 (/ p) (+ (* 253 mu2) (* -3722 mu) 17869) p0))
		 q1 (if (= (+ 1 p) p) 0d0 (* 1.6d0 (/ p) (+ (* 83 mu2) (* -982 mu) 3779))))
	   (setf p (+ (* 7 mu2) (* 82 mu) -9)
		 p0 (+ mu 3)
		 p1 (if (= (+ 1 p) p) 0d0 (* (/ p) (/ 60) (+ (* 4048 mu4) (* 131264 mu3) (* -221984 mu2) (* -417600 mu) 1012176)))
		 q1 (if (= (+ 1 p) p) 0d0 (* 1.6d0 (/ p) (+ (* 83 mu3) (* 2074 mu2) (* -3039 mu) 3537)))))
       (let* ((vt (if (or (= 1 d) (= 4 d)) .25d0 .75d0))
	      (tt (* 4 vt)))
	 (if (< d 3)
	     (setf pp1 (coerce 5/48 'double-float)   qq1 (coerce -5/36 'double-float))
	     (setf pp1 (coerce -7/48 'double-float)  qq1 (coerce 35/288 'double-float)))
	 
	 (let ((bb (if (<= 3 a) (expt a -2/3) 1d0))
	       (a1 (+ (* 3 a) -8))
	       (y (* .375 pi))
	       (xx 0d0) (j 0d0) (b 0d0)  (c 0d0) (u 0d0) (v 0d0) (w 0d0) (a2 0d0) (q 0d0) (ro 0d0) (x4 0d0))
	   (setf psi (* pi (+ (* .5 a) .25)))
	   (loop for s from 1 upto n do
		(if (and (= a 0) (= s 1) (= d 3))
		    (setf x 0d0 j 0d0)
		    (progn
		      (if (<= a1 s)
			  (setf b (* pi (+ s (* .5 a) (- vt)))
				c (/ .015625d0 (* b b))
				x (+ b (* -.125 (/ (- p0 (* p1 c))
						   (* b (+ -1 (* q1 c)))))))
			  (progn 
			    (if (= s 1)
				(setf x (ecase d 
					  (1 -2.33811d0)
					  (2 -1.17371d0)
					  (3 -1.01879d0)
					  (4 -2.29444d0)))
				(setf x (* y (+ (* 4 s) (- tt)))
				      v (/ (* x x))
				      x (* (- (expt x 2/3)) (+ 1 (* v (+ pp1 (* qq1 v)))))))
			    (setf u (* x bb)
				  v (fi (* 2/3 (expt (- u) 1.5)))
				  w (/ (cos v))
				  xx (+ 1 (- (* w w)))
				  c (sqrt (/ u xx))
				  x (* w (+ a (* (/ c (* 48 a u))
						 (if (< d 3)
						     (+ (/ -5 u) (- (* c (+ (/ -10 xx) 6))))
						     (+ (/ 7 u) (* c (+ (/ -14 xx) 18))))))))))
		      (setf j 0)
		      (tagbody l1
			 (setf xx (* x x)
			       x4 (* xx xx)
			       a2 (- aa xx)
			       ro (bessr d a x)
			       j (+ j 1))
			 (if (< d 3)
			     (setf u ro
				   w (* 6 x (+ (* 2 a) 1))
				   p (/ (+ 1 (* -4 a2)) 
					w)
				   q (/ (+ (* 4 (- xx mu))
					   -2 (* -12 a)) w))
			     (setf u (- (* xx ro (/ a2)))
				   v (* 2 x a2 (/ (* 3 (+ aa xx))))
				   w (* 64 a2 a2 a2)
				   q (* 2 v (+ 1 mu2 (* 32 mu xx) (* 48 x4))
					(/ w))
				   p (* v (+ 1 (/ (+ (- mu2) (* 40 mu xx) (* 48 x4)) 
						  w)))))
			 (setf w (* u (/ (+ 1 (* p ro))
					 (+ 1 (* q ro))))
			       x (+ x w))
			 (when (and (< e (abs (/ w x)) ) (< j 5))
			   (go l1)))
		      (setf (aref z (- s 1)) x))))
	   (return-from bess-zeros z)))))))

#+nil
(bess-zeros :a 1)
